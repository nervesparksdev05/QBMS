def generate_diagrams_for_selected_questions(questions):     """     Generate diagrams only for questions that have been selected by the user      Args:         questions (list): List of question dictionaries      Returns:     """     diagrams = {}      for question in questions:         if question.get('user_selected_for_diagram', False):             question_id = question.get('id')             matplotlib_code = generate_diagram_for_question(question)             if matplotlib_code:                 diagrams[question_id] = matplotlib_code      return diagrams  def generate_diagram_for_question(question):     """     Generate matplotlib Python code for a single question      Args:         question (dict): Question dictionary with diagram description      Returns:         str: Python matplotlib code for the diagram     """     try:         description = question.get('diagram_description', '')         q_text = question.get('question', '')         subject = question.get('subject', 'Physics')          template = load_prompt_template("diagram_gen.txt")          prompt = template.format(             description=description,             subject=subject,             question=q_text         )          print(f"Generating diagram for question {question.get('id')}: {q_text[:50]}...")          response = requests.post('http://192.168.31.137:11434/api/generate',                                json={                                    "model": "gemma3:27b",                                    "prompt": prompt,                                    "stream": False                                })          if response.status_code == 200:             response_data = response.json()             matplotlib_code = response_data.get('response', '')              # Remove any code block markers if present             matplotlib_code = re.sub(r'```python\s*|\s*```', '', matplotlib_code)             matplotlib_code = matplotlib_code.strip()              return matplotlib_code         else:             print(f"Error calling Ollama API: {response.status_code}")             print(response.text)             return ""      except Exception as e:         print(f"Error generating diagram: {str(e)}")         traceback.print_exc()         return ""  def generate_diagram_for_question(question):     """     Generate matplotlib Python code for a single question with validation checks and refinement      Args:         question (dict): Question dictionary with diagram description      Returns:         str: Python matplotlib code for the diagram     """     try:         description = question.get('diagram_description', '')         q_text = question.get('question', '')         subject = question.get('subject', 'Physics')          template = load_prompt_template("diagram_gen.txt")          prompt = template.format(             description=description,             subject=subject,             question=q_text         )          print(f"Generating diagram for question {question.get('id')}: {q_text[:50]}...")          # First call to generate initial diagram code         response = requests.post('http://192.168.31.137:11434/api/generate',                                json={                                    "model": "gemma3:27b",                                    "prompt": prompt,                                    "stream": False                                })          if response.status_code == 200:             response_data = response.json()             initial_code = response_data.get('response', '')              # Remove any code block markers if present             initial_code = re.sub(r'```python\s*|\s*```', '', initial_code)             initial_code = initial_code.strip()              # Validation check 1: Check if code contains import matplotlib             if 'import matplotlib' not in initial_code:                 print("Validation failed: Missing matplotlib import. Regenerating...")                 return generate_diagram_for_question(question)  # Recursive retry              # Validation check 2: Check if code contains basic plotting functions             if 'plt.figure' not in initial_code or ('plt.plot' not in initial_code and 'plt.scatter' not in initial_code                  and 'plt.bar' not in initial_code and 'plt.text' not in initial_code):                 print("Validation failed: Missing essential plotting functions. Regenerating...")                 return generate_diagram_for_question(question)  # Recursive retry              # Validation check 3: Check code length is reasonable             if len(initial_code.split('\n')) < 5:                 print("Validation failed: Code too short. Regenerating...")                 return generate_diagram_for_question(question)  # Recursive retry                              # Refinement step: Send the initial code back for improvement             refinement_prompt = f"""             Refine the following matplotlib diagram code to ensure it perfectly matches the question and description.                          Question: {q_text}             Description: {description}             Subject: {subject}                          Current code:             {initial_code}                          Please improve this code by:             1. Making sure all necessary elements from the question are visualized             2. Ensuring all labels are clear and properly positioned             3. Removing any unnecessary elements             4. Using appropriate colors and styles for educational diagrams             5. Making sure the code is clean and will execute without errors                          Return only the complete revised Python code with no explanations.             """                          refine_response = requests.post('http://192.168.31.137:11434/api/generate',                                    json={                                        "model": "gemma3:27b",                                        "prompt": refinement_prompt,                                        "stream": False                                    })                                                 if refine_response.status_code == 200:                 refine_data = refine_response.json()                 refined_code = refine_data.get('response', '')                                  # Clean up refined code                 refined_code = re.sub(r'```python\s*|\s*```', '', refined_code)                 refined_code = refined_code.strip()                                  # Final validation: If refined code looks worse or broke something, keep original                 if 'import matplotlib' not in refined_code or len(refined_code.split('\n')) < 5:                     print("Refinement produced invalid code. Using original code.")                     return initial_code                                      print("Successfully refined diagram code")                 return refined_code             else:                 # If refinement fails, return initial code                 print("Refinement API call failed. Using original code.")                 return initial_code         else:             print(f"Error calling Ollama API: {response.status_code}")             print(response.text)             return ""      except Exception as e:         print(f"Error generating diagram: {str(e)}")         traceback.print_exc()         return ""  def generate_diagram_with_instructions(question, instructions):     """     Generate a modified diagram based on user instructions.      Args:         question (dict): The question dictionary containing original diagram data         instructions (str): User instructions for modifying the diagram      Returns:         str: Modified diagram code     """     try:         # Prepare the prompt for diagram modification         description = question.get('diagram_description', '')         q_text = question.get('question', '')         subject = question.get('subject', 'Physics')         original_code = question.get('matplot_lib', '')          # Load diagram generation template or use default         template = """Modify the existing diagram code based on the following instructions:  Original diagram description: {description} Subject area: {subject} Question context: {question} User modification instructions: {instructions}  Original diagram code: {original_code}  Please modify the code to incorporate the user's instructions. Return the complete, modified code. Ensure the diagram remains suitable for an exam question paper with minimal styling, clear labels.  Return only the modified code, no explanations or additional text. """          # Format prompt with all necessary information         prompt = template.format(             description=description,             subject=subject,             question=q_text,             instructions=instructions,             original_code=original_code         )          print(f"Generating modified diagram for question {question.get('id')}: {q_text[:50]}...")          # Call the model to generate the modified diagram         response = requests.post('http://192.168.31.137:11434/api/generate',                                json={                                    "model": "gemma3:27b",                                    "prompt": prompt,                                    "stream": False                                })          if response.status_code == 200:             response_data = response.json()             modified_code = response_data.get('response', '')             print("------------------------------> diagram generated with instruction", modified_code)             # Remove any code block markers if present             modified_code = re.sub(r'```python\s*|\s*```', '', modified_code)             modified_code = modified_code.strip()              # Save the modification instructions in the question for reference             from datetime import datetime             question['diagram_modification_history'] = question.get('diagram_modification_history', [])             question['diagram_modification_history'].append({                 'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),                 'instructions': instructions             })              return modified_code         else:             print(f"Error calling Ollama API: {response.status_code}")             print(response.text)             return ""      except Exception as e:         print(f"Error generating modified diagram: {str(e)}")         traceback.print_exc()         return "" this is my code for generating the diagram for selected question ,  def display_matplotlib_diagram(buffer, caption="Diagram"):     """     Display a matplotlib diagram from a BytesIO buffer in Streamlit with reduced size     """     if buffer and buffer.getvalue():         st.image(buffer, caption=caption, width=300) # Keep width constraint     else:         # Don't display warning here, the calling function handles absence         pass # Or maybe log an error if buffer was expected  # Function to display questions with diagrams and selection checkboxes - FIXED to avoid nested expanders def display_questions_with_selection(questions, show_diagrams=True, enable_selection=False):     selected_question_ids = [] # Renamed for clarity      for i, question in enumerate(questions):         question_id = question.get('id', f'q{i+1}')         # Generate a simple but unique key by combining question ID, index, and session timestamp         # This will ensure uniqueness across page reruns         if 'session_timestamp' not in st.session_state:             import time             st.session_state.session_timestamp = str(int(time.time()))                  unique_key_base = f"{question_id}_{i}_{st.session_state.session_timestamp}"          st.markdown(f"### Question {i+1} ({question.get('difficulty', 'medium').capitalize()})")          # --- Checkbox Logic ---         if enable_selection:             # Checkbox is always available if selection is enabled             # Label changes based on whether diagram code already exists             has_generated_code = bool(question.get('diagram_matplotlib'))             checkbox_label = "Regenerate diagram" if has_generated_code else "Select to generate diagram"             is_selected = st.checkbox(checkbox_label, key=f"select_{unique_key_base}")             if is_selected:                 selected_question_ids.append(question_id) # Collect IDs for processing later          st.markdown(f"**{question['question']}**")          # --- Diagram Display Logic ---         # Only show the diagram section if diagram_matplotlib *actually exists*         if show_diagrams and question.get('diagram_matplotlib'):             st.subheader("Diagram")             try:                 # Attempt to render the existing diagram code                 diagram_buffer = render_diagram(question['diagram_matplotlib'], question_id)                  if diagram_buffer:                     display_matplotlib_diagram(                         diagram_buffer,                         caption=f"Diagram for Question {i+1}"                     )                      # --- Modification Controls (with unique keys) ---                     instructions_key = f"instructions_{i}_{question_id}"                     modify_key = f"modify_{i}_{question_id}"                      modification_instructions = st.text_area(                         "Instructions to modify diagram:",                         "",                         key=instructions_key,                         height=100                     )                      if st.button("Modify Diagram", key=modify_key):                         if modification_instructions:                             with st.spinner("Regenerating diagram with new instructions..."):                                 try:                                     modified_diagram_code = generate_diagram_with_instructions(                                         question,                                         modification_instructions                                     )                                      if modified_diagram_code:                                         # Update question state *immediately* for re-render                                         question['diagram_matplotlib'] = modified_diagram_code                                         st.success("Diagram modification code generated! Re-rendering...")                                         st.rerun() # Rerun to display the modified diagram                                     else:                                         st.error("Failed to generate modified diagram code.")                                 except ImportError:                                      st.error("Diagram modification function not available.")                                 except Exception as gen_e:                                      st.error(f"Error during diagram modification: {gen_e}")                         else:                             st.warning("Please enter modification instructions.")                 else:                     # Code exists, but rendering failed                     st.warning(f"Diagram code exists for Question {i+1}, but failed to render.")             except Exception as e:                 st.error(f"Error displaying diagram for Question {i+1}: {str(e)}")          # --- Options Display ---         st.subheader("Options")         options = question.get('options', [])         correct_answer = question.get('correct_answer', '') # Ensure correct_answer is available         if not options:              st.warning("No options generated for this question.")         else:             for j, option in enumerate(options):                 option_letter = chr(65 + j)                 is_correct = option == correct_answer                  if is_correct:                     st.markdown(f"- {option_letter}. {option}")                 else:                     st.markdown(f"- {option_letter}. {option}")          st.caption(f"Source: {question.get('source', 'Not specified')}")         st.markdown("---")      return selected_question_ids # Return the list of IDs selected via checkbox  # New function to generate a diagram with modification instructions def generate_diagram_with_instructions(question, instructions):     """     Generate a modified diagram based on user instructions.          Args:         question (dict): The question dictionary containing original diagram data         instructions (str): User instructions for modifying the diagram              Returns:         str: Modified diagram code     """     try:         # Prepare the prompt for diagram modification         description = question.get('diagram_description', '')         q_text = question.get('question', '')         subject = question.get('subject', 'Physics')         original_code = question.get('diagram_matplotlib', '')                  # Load diagram generation template                  # If template doesn't exist, create a default one                  template = """Modify the existing diagram code based on the following instructions:  Original diagram description: {description} Subject area: {subject} Question context: {question} User modification instructions: {instructions}  Original diagram code: {original_code}  Please modify the code to incorporate the user's instructions. Return the complete, modified code. Ensure the diagram remains suitable for an exam question paper with minimal styling, clear labels, and no color (only use black lines, markers, and text), and stictly dont give me answer for the question only give necessesary information.  Return only the modified code, no explanations or additional text. """                  # Format prompt with all necessary information         prompt = template.format(             description=description,             subject=subject,             question=q_text,             instructions=instructions,             original_code=original_code         )                  print(f"Generating modified diagram for question {question.get('id')}: {q_text[:50]}...")                  # Call the model to generate the modified diagram         response = requests.post('http://192.168.31.137:11434/api/generate',                                 json={                                    "model": "gemma3:27b",                                    "prompt": prompt,                                    "stream": False                                })                  if response.status_code == 200:             response_data = response.json()             modified_code = response_data.get('response', '')                          # Remove any code block markers if present             modified_code = re.sub(r'```python\s*|\s*```', '', modified_code)             modified_code = modified_code.strip()                          # Save the modification instructions in the question for reference             question['diagram_modification_history'] = question.get('diagram_modification_history', [])             question['diagram_modification_history'].append({                 'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),                 'instructions': instructions             })                          return modified_code         else:             print(f"Error calling Ollama API: {response.status_code}")             print(response.text)             return ""                  except Exception as e:         print(f"Error generating modified diagram: {str(e)}")         traceback.print_exc()         return ""  def render_diagram(matplotlib_code, question_id):     """     Render diagram code to an in-memory buffer using matplotlib          Args:         latex_code (str): Code for the diagram (now expected to be matplotlib Python code)         question_id (str): ID of the question              Returns:         BytesIO: Buffer containing the rendered image     """     try:         if matplotlib_code.strip().startswith('\\') or '\\documentclass' in matplotlib_code:             fig = plt.figure(figsize=(6, 4))             plt.text(0.5, 0.5, "Complex LaTeX diagram\n(Rendered as placeholder)",                      size=16, ha='center', va='center')             plt.axis('off')             buffer = BytesIO()             plt.savefig(buffer, format='png', dpi=200, bbox_inches='tight')             plt.close(fig)             buffer.seek(0)             return buffer         else:             return render_matplotlib_code(matplotlib_code, question_id)                  except Exception as e:         print(f"Error rendering diagram: {e}")         traceback.print_exc()         return None  def render_matplotlib_code(code, question_id, diagram_type=None, figsize=(4, 3), dpi=150):     """     Render matplotlib Python code to an in-memory buffer with enhanced functionality.          Parameters:     - code (str): Matplotlib code to render     - question_id (str): Unique identifier for the diagram     - diagram_type (str, optional): Type of diagram ('plot', 'scatter', 'bar', 'pie', etc.)     - figsize (tuple, optional): Figure size in inches (width, height)     - dpi (int, optional): Dots per inch for output resolution          Returns:     - BytesIO buffer containing the rendered diagram or None if rendering fails     """     try:         # Suppress matplotlib warnings         warnings.filterwarnings("ignore", category=matplotlib.MatplotlibDeprecationWarning)                  # Clean code input         if "```python" in code:             code_match = re.search(r'```python\s*(.+?)\s*```', code, re.DOTALL)             if code_match:                 code = code_match.group(1).strip()                  # Remove unwanted matplotlib calls         code = re.sub(r"plt\.show$$  $$", "", code)         code = re.sub(r"plt\.savefig$$ [^ $$]+\)", "", code)         code = re.sub(r"plt\.close$$  $$", "", code)                  # Initialize figure with specified size         base_code = f""" plt.figure(figsize={figsize}, constrained_layout=True) """                  # Optimize plot settings based on diagram type         if diagram_type:             settings = {                 'plot': """ plt.grid(True, linestyle='--', alpha=0.7) plt.style.use('seaborn') """,                 'scatter': """ plt.grid(True, linestyle='--', alpha=0.7) plt.style.use('seaborn') """,                 'bar': """ plt.style.use('ggplot') """,                 'pie': """ plt.axis('equal') """,                 'histogram': """ plt.style.use('seaborn') plt.grid(True, axis='y', alpha=0.7) """,                 'box': """ plt.grid(True, axis='y', alpha=0.7) plt.style.use('seaborn') """             }             base_code += settings.get(diagram_type.lower(), "")                  # Combine base settings with user code         code = base_code + code                  # Prepare buffer for output         buffer = BytesIO()                  # Add save command with optimized settings         save_code = f""" plt.savefig(buffer, format='png', dpi={dpi}, bbox_inches='tight',             transparent=False, facecolor='white') plt.close() buffer.seek(0) """         code += save_code                  # Enhanced execution environment         exec_globals = {             'plt': plt,             'np': np,             'math': math,             'buffer': buffer,             '__builtins__': __builtins__,             'pd': __import__('pandas') if 'pandas' in code else None,             'sns': __import__('seaborn') if 'seaborn' in code else None,         }                  # Execute with error handling         with warnings.catch_warnings():             warnings.simplefilter("ignore")             exec(code, exec_globals)                  # Verify buffer content         if not buffer.getvalue():             print(f"Empty buffer for question {question_id}")             return None                      return buffer              except Exception as e:         print(f"Error rendering matplotlib code for question {question_id}: {str(e)}")         traceback.print_exc()         return None  # Function to process diagrams for specific questions def process_diagrams_for_selected_questions(all_questions, selected_ids):     updated_questions = update_questions_with_user_selections(all_questions, selected_ids)     diagram_matplotlib_code = generate_diagrams_for_selected_questions(updated_questions)          for question in updated_questions:         question_id = question.get('id')         if question_id in diagram_matplotlib_code:             question['requires_diagram'] = True             question['diagram_matplotlib'] = diagram_matplotlib_code[question_id]          return updated_questions  # Function to filter questions with diagrams def filter_diagram_questions(questions):     """Filter questions that require diagrams"""     return [q for q in questions if q.get('requires_diagram', False)]  this is my app.py file code for displaying and regenerating the diagram ,
def generate_questions(content, subject, num_questions, difficulty_distribution):
    try:
        # Format difficulty distribution for prompt - ensure we're using the correct counts
        difficulty_format = ", ".join([f"{count} {level}" for level, count in difficulty_distribution.items() if count > 0])

        # Validate that the sum of difficulties equals num_questions
        total_difficulty_count = sum(difficulty_distribution.values())
        if total_difficulty_count != num_questions:
            # Adjust the hard difficulty to make the total match
            difficulty_distribution["hard"] = max(0, num_questions - difficulty_distribution["easy"] - difficulty_distribution["medium"])
            # Re-format with adjusted values
            difficulty_format = ", ".join([f"{count} {level}" for level, count in difficulty_distribution.items() if count > 0])

        # Format content for prompt
        content_formatted = "\n\n".join([f"--- {('Chapter' if len(content) > 1 else 'Page')} {num} ---\n{text}"
                                      for num, text in content.items()])

        # Load question generation prompt template
        template = load_prompt_template("question_gen.txt")

        # Format prompt with stronger emphasis on question count and difficulty distribution
        prompt = template.format(
            num_questions=num_questions,
            difficulty_distribution=difficulty_format,
            subject=subject,
            content=content_formatted
        )

        # Add explicit instructions about question count and difficulty distribution
        prompt = prompt.replace("Generate {num_questions} questions",
                               f"Generate EXACTLY {num_questions} questions. This is a requirement, not a suggestion.")
        prompt = prompt.replace("of varying difficulty: {difficulty_distribution}",
                               f"with EXACTLY this difficulty distribution: {difficulty_format}. Do not deviate from this distribution.")
        # Call Ollama API
        response = requests.post('http://192.168.31.137:11434/api/generate',
                               json={
                                   "model": "gemma3:27b",
                                   "prompt": prompt,
                                   "stream": False
                               })

        if response.status_code == 200:
            response_data = response.json()
            # Extract JSON from response
            generated_text = response_data.get('response', '')
            print("==================================> generated text")
            json_match = re.search(r'```json\s*(.+?)\s*```', generated_text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
            else:
                # Try to find JSON without code blocks
                json_match = re.search(r'(\{.*"questions":\s*\[.+?\]\s*\})', generated_text, re.DOTALL)
                if json_match:
                    json_str = json_match.group(1)
                else:
                    json_str = generated_text
            try:
                # Parse JSON
                result = json.loads(json_str)
                questions = result.get('questions', [])
                print("<><><><><><><><><><><><>Question generated")
                # Ensure exactly num_questions are returned
                if len(questions) < num_questions:
                    # If too few questions, try a second request for the remaining questions
                    print(f"Model returned only {len(questions)} questions. Requesting {num_questions - len(questions)} more...")

                    # Request for remaining questions
                    remaining_prompt = prompt.replace(
                        f"Generate EXACTLY {num_questions} questions",
                        f"Generate EXACTLY {num_questions - len(questions)} additional questions"
                    )

                    additional_questions = request_additional_questions(
                        remaining_prompt,
                        num_questions - len(questions)
                    )

                    # Combine questions
                    questions.extend(additional_questions)

                # If still too many or too few, adjust the list
                if len(questions) > num_questions:
                    questions = questions[:num_questions]  # Truncate if too many

                # Ensure each question has required fields
                for i, question in enumerate(questions):
                    if 'id' not in question:
                        question['id'] = f"q{i+1}"
                    if 'requires_diagram' not in question:
                        question['requires_diagram'] = True
                    if 'diagram_description' not in question:
                        question['diagram_description'] = f"Diagram for question: {question['question']}"
                    if 'confidence_score' not in question:
                        question['confidence_score'] = 0.8  # Default confidence score
                    # Add a new field to track if user has selected this question for diagram generation
                    question['user_selected_for_diagram'] = False
                    # Add subject field for later use
                    question['subject'] = subject

                return questions
            except json.JSONDecodeError:
                print("Failed to parse JSON from model response")
                print("Response:", generated_text[:500])  # Print part of the response for debugging
                return []

        else:
            print(f"Error calling Ollama API: {response.status_code}")
            print(response.text)
            return []

    except Exception as e:
        print(f"Error generating questions: {str(e)}")
        traceback.print_exc()
        return []

this is my question generating 